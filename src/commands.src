// 
// Marinette's commands




command "help", ["h", "?"], Const.any, Messages.HelpEntryHelp, function(arguments)
    commands = Helps.indexes
    if arguments.len != 0 then commands = arguments

    foundHelps = {}

    for command in commands
        if Commands.indexes.indexOf(command) == null then
            for kv in Aliases
                if kv.value.indexOf(command) != null then
                    command = kv.key
                    break
                end if
            end for
            if Commands.indexes.indexOf(command) == null then
                continue
            end if
        end if
        if Aliases.indexes.indexOf(command) != null then 
            aliases = Aliases[command]
            commands = [command] + aliases
        else
            commands = [command]
        end if
        commands = commands.join(", ")
        categories = Messages.HelpUndeterminedDescription
        args = Messages.HelpNoArguments
        description = Messages.HelpUndeterminedDescription

        if Helps.indexes.indexOf(command) != null then
            help = Helps[command]
            parts = help.split(" - ")

            if parts.len == 1 then 
                description = parts[0]
            else if parts.len == 2 then
                categories = parts[0]
                description = parts[1]
            else if parts.len == 3 then
                categories = parts[0]
                args = parts[1]
                description = parts[2]
            end if
        end if
        
        help = {
            "commands": commands,
            "args": args,
            "description": description,
        }

        if foundHelps.indexes.indexOf(categories) == null then foundHelps[categories] = []
        foundHelps[categories].push(help)
    end for

    printCategories = function(categories)
        print(primary("<b><--"+categories+"--></b>"))
        for help in foundHelps[categories]
            print(primary(help.commands)+secondary(" - "+help.args+" - "+help.description))
        end for
    end function

    if foundHelps.len > 0 then 
        categories = removeDuplicates(foundHelps.indexes)
        typePredicate = function(iItem, jItem)
            priority = {
                Messages.SessionTypeAny: "A"*32,
                Messages.SessionTypeHost: "A"*31+"B",
                Messages.SessionTypeShell: "A"*31+"C",
                Messages.SessionTypeComputer: "A"*31+"D",
                Messages.SessionTypeFile: "A"*31+"E",
                Messages.HelpUndeterminedDescription: "A"*31+"F",
            }
            if priority.indexes.indexOf(iItem) == null then priority[iItem] = iItem
            if priority.indexes.indexOf(jItem) == null then priority[jItem] = jItem
            return priority[iItem] > priority[jItem]
        end function
        mergeSort(categories, @typePredicate)

        last = categories.pop
        for category in categories
            printCategories(category)
            print(" ")
        end for
        printCategories(last)
    else
        Console.error(Messages.ErrorNoHelpEntries)
    end if
end function


command "credits", [], Const.any, Messages.HelpEntryLicense, function(arguments)
    Conditions.arguments(arguments, 0)

    contributors = [
        "Kurouzu", "Joe Strout", "Clover", "Roupi",
        "Finko42", "Ariavne", "Guest", "Simonize",
    ]

    print(primary(Messages.SpecialThanksAndCredits))
    print(" ")
    print(primary(contributors.join(", ")))
    print(" ")
    print(primary(Messages.YouAreAllAwesome+" <3"))
end function


command "quit", ["q", "exit"], Const.any, Messages.HelpEntryQuit, function(arguments)
    Conditions.arguments(arguments, 0)

    Console.log(Messages.LogThanksAndQuit)
    exit
end function


command "clear", ["cls"], Const.any, Messages.HelpEntryClear, function(arguments)
    Conditions.arguments(arguments, 0)

    clear_screen
end function


command "sessions", [], Const.any, Messages.HelpEntrySm, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    
    command = arguments.pull
    if "add".indexOf(command) == 0  and arguments.len != 0 then return Conditions.arguments(arguments, 1)
    if "delete".indexOf(command) == 0 and arguments.len == 0 then return Conditions.argumentsMoreThan(arguments, 1)
    if "use".indexOf(command) == 0 and arguments.len != 1 then return Conditions.arguments(arguments, 2)
    if "look".indexOf(command) == 0 and arguments.len != 0 then return Conditions.argumentsMoreThan(arguments, 1)

    if "add".indexOf(command) == 0 then
        SessionsHelpers.add(Intrinsics)
        Console.log(Messages.LogSuccessfullSessionsUpdate)
    else if "delete".indexOf(command) == 0 then
        i = 0; while i < arguments.len; i = i + 1
            id = arguments[i-1]
            if id isa string or not SessionsHelpers.delete(id) then
                Console.error(Messages.ErrorIncorrectSessionId)
            else
                j = i-1; while j < arguments.len; j = j + 1
                    arguments[j-1] = arguments[j-1] - 1
                end while
                Console.log(Messages.LogSuccessfullSessionDeletion, {"ID": id})
            end if
        end while
    else if "use".indexOf(command) == 0 then
        id = arguments[0]
        if id isa string or not SessionsHelpers.get(id) then return Console.error(Messages.ErrorIncorrectSessionId)
        session = SessionsHelpers.get(id)
        globals.Intrinsics = session.Intrinsics
        Console.log(Messages.LogSuccessfullSessionLoad)
    else if "look".indexOf(command) == 0 then
        output = Messages.SmHeader
        i = 1
        while SessionsHelpers.get(i) != null
            session = SessionsHelpers.get(i)
            output = output+char(10)+(i)+" "+session.name
            i = i + 1
        end while
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if
end function


command "theme", [], Const.any, Messages.HelpEntryTheme, function(arguments)
    Conditions.arguments(arguments, 0)
    
    asciiArt = [
        "  __  __          _          _   _       ",
        " |  \/  |__ _ _ _(_)_ _  ___| |_| |_ ___ ",
        " | |\/| / _` | '_| | ' \/ -_)  _|  _/ -_)",
        " |_|  |_\__,_|_| |_|_||_\___|\__|\__\___|",
    ]
    Console.asciiArt(asciiArt)

    print(" ")

    Console.log(randomString(40))
    Console.warning(randomString(40))
    Console.error(randomString(40))

    print(" ")
    table = [
        randomString(10)+" "+randomString(10)+" "+randomString(10)+" "+randomString(10),
        "---------- ---------- ---------- ----------",
        randomString(11)+" "+randomString(11)+" "+randomString(11)+" "+randomString(11),
        randomString(12)+" "+randomString(12)+" "+randomString(12)+" "+randomString(12),
    ].join(char(10))
    print(formatColumnsColored(table, Theme.miscPrimary, Theme.miscSecondary))
end function




command "systeminfo", ["sysinf", "si"], Const.host, Messages.HelpEntrySysinf, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.host

    shell = get_shell
    computer = shell.host_computer

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfLocalSystem+"-->")
    if user_bank_number then bank = user_bank_number else bank = Messages.SysInfUnavailable
    if user_mail_address then mail = user_mail_address else mail = Messages.SysInfUnavailable
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfUserName+" <color="+Theme.miscSecondary+">- "+active_user)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfHostName+" <color="+Theme.miscSecondary+">- "+computer.get_name)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfHomePath+" <color="+Theme.miscSecondary+">- "+home_dir)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfBankLogin+" <color="+Theme.miscSecondary+">- "+bank)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfEmail+" <color="+Theme.miscSecondary+">- "+mail)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfProgramPath+" <color="+Theme.miscSecondary+">- "+program_path)
    print("")

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfNetwork+"-->")
    bssid = Messages.SysInfUnavailable
    essid = Messages.SysInfUnavailable
    kernel = Messages.SysInfUnavailable
    localIp = Messages.SysInfUnavailable
    publicIp = Messages.SysInfUnavailable
    deviceIp = Messages.SysInfUnavailable
    if computer.is_network_active then
        router = getNetworkNode
        bssid = router.bssid_name
        essid = router.essid_name
        kernel = router.kernel_version
        localIp = router.local_ip
        publicIp = router.public_ip
        deviceIp = computer.local_ip
    end if
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfMacAddress+" <color="+Theme.miscSecondary+">- "+bssid)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfNetworkName+" <color="+Theme.miscSecondary+">- "+essid)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfKernelVersion+" <color="+Theme.miscSecondary+">- "+kernel)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfLocalAddress+" <color="+Theme.miscSecondary+">- "+localIp)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfPublicAddress+" <color="+Theme.miscSecondary+">- "+publicIp)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfDeviceAddress+" <color="+Theme.miscSecondary+">- "+deviceIp)
    print(" ")

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfLibraries+"-->")
    crypto = Messages.SysInfNotLoaded
    apt = Messages.SysInfNotLoaded
    metaxploit = Messages.SysInfNotLoaded
    blockchain = Messages.SysInfNotLoaded
    if Libs.indexes.indexOf("crypto") != null then crypto = Messages.SysInfLoaded
    if Libs.indexes.indexOf("apt") != null then apt = Messages.SysInfLoaded
    if Libs.indexes.indexOf("metaxploit") != null then metaxploit = Messages.SysInfLoaded
    if Libs.indexes.indexOf("blockchain") != null then blockchain = Messages.SysInfLoaded
    print("<color="+Theme.miscPrimary+">Crypto <color="+Theme.miscSecondary+">- "+crypto)
    print("<color="+Theme.miscPrimary+">Apt <color="+Theme.miscSecondary+">- "+apt)
    print("<color="+Theme.miscPrimary+">Metaxploit <color="+Theme.miscSecondary+">- "+metaxploit)
    print("<color="+Theme.miscPrimary+">Blockchain <color="+Theme.miscSecondary+">- "+blockchain)
    print(" ")

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfMiscellaneous+"-->")
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfDateTime+" <color="+Theme.miscSecondary+">- "+current_date)
end function


command "reload", ["rl"], Const.host, Messages.HelpEntryReload, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.host

    performRuntimeLoading
    performSystemChecks
end function


command "subuser", ["subu"], Const.host, Messages.HelpEntryUserchange, function(arguments)
    Conditions.arguments(arguments, 2)
    Conditions.host

    user = str(arguments[0])
    pass = str(arguments[1])
    
    shell = get_shell(user, pass)
    if not shell then
        Console.error(Messages.ErrorIncorrectUsernameOrPassword)
    else
        Console.log(Messages.LogLookingForMyself)
        // Now that I think of it - this is potentially a security vulnerability. Should be cautious.
        fd = findMyself(get_shell, Config.identificator, "--identify-marinette --password "+Var.password)
        if not fd then return Console.error(Messages.ErrorCouldNotFindMyself)

        Intrinsics.shell = shell
        Intrinsics.computer = Intrinsics.shell.host_computer
        Intrinsics.file = Intrinsics.computer.File("/")
        
        shared = get_custom_object
        shared.Var = deepCopy(Var)
        shared.Intrinsics = deepCopy(Intrinsics)
        shared.Libs = deepCopy(Libs)
        shared.Sessions = deepCopy(Sessions)

        shell.launch(fd.path, "--no-ascii-art --password "+Var.password)
        exit
    end if
end function


command "svcon", ["sc"], Const.host, Messages.HelpEntrySvcon, function(arguments)
    Conditions.arguments(arguments, 6)
    Conditions.host
    Conditions.network

    addr = str(arguments[0])
    locAddr = str(arguments[1])
    port = arguments[2]
    user = str(arguments[3])
    pass = str(arguments[4])
    svc = str(arguments[5])


    router = getNetworkNode(addr)
    if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
    
    addr = router.public_ip
    if isNodeLocallyAccessible(router) then addr = router.local_ip

    svcPort = getExactPort(addr, locAddr, port)
    if not svcPort then return Console.error(Messages.ErrorCouldNotAccessSuchPort)

    target = addr
    if isNodeLocallyAccessible(router) then target = locAddr
    result = Intrinsics.shell.connect_service(addr, port, user, pass, svc)
    if not result then return Console.error(Messages.ErrorConnectionFailed)
    if ["shell", "ftpshell"].indexOf(typeof(result)) == null then Console.error(Messages.ErrorConnectionUnknownShell)
    
    intrinsics = deepCopy(Intrinsics)
    intrinsics.shell = result
    intrinsics.computer = intrinsics.shell.host_computer
    intrinsics.file = intrinsics.computer.File("/")
    intrinsics.publicAddress = intrinsics.computer.public_ip
    intrinsics.localAddress = intrinsics.computer.local_ip
    intrinsics.port = port
    intrinsics.isConnectionRemote = true
    
    SessionsHelpers.add(intrinsics)
    Console.log(Messages.LogSuccessfullSessionsUpdate)
end function


// 
// Thanks Ariavne for allowing me to use their nickname as a tool name :D
command "ariadne", ["aria"], Const.host, Messages.HelpEntryAriadne, function(arguments)
    Conditions.host
    Conditions.metaxploit

    fd = Intrinsics.file
    metaxploit = Libs.metaxploit
    
    while fd.parent
        fd = fd.parent
    end while

    Console.log(Messages.LogSearchingForLocalLibraries)
    metalibs = []
    files = [] + fd.get_folders + fd.get_files
    while files.len > 0
        fd = files.pull
        if fd.is_folder then 
            files = fd.get_folders + fd.get_files + files
            continue
        end if

        if not fd.is_binary then continue
        metalib = metaxploit.load(fd.path)
        if not metalib then continue
        isAlreadyFound = false
        for foundLib in metalibs
            if foundLib.lib_name == metalib.lib_name and foundLib.version == metalib.version then
                isAlreadyFound = true
                break
            end if
        end for
        if not isAlreadyFound then metalibs.push(metalib)
    end while
    
    Console.log(Messages.LogScanningLocalLibraries, {"AMOUNT": metalibs.len})
    exploits = []
    for metalib in metalibs
        memory = metaxploit.scan(metalib)
        for address in memory
            vulners = scanMemoryAddress(metaxploit, metalib, address)
            exploits.push({"metalib": metalib, "address": address, "vulners": vulners})
        end for
    end for

    if exploits.len == 0 then return Console.error(Messages.ErrorNoExploitsInScannedLibraries)
    
    Console.log(Messages.LogExploitingVulnerabilities)
    results = []
    for exploit in exploits
        for vulner in exploit.vulners
            ofArgs = [null]
            if arguments.len > 0 then ofArgs = ofArgs + fmap(@str, arguments)
            ofArgs = removeDuplicates(ofArgs)
            for ofArg in ofArgs
                if ofArg == null then
                    result = exploit.metalib.overflow(exploit.address, vulner.value)
                else
                    result = exploit.metalib.overflow(exploit.address, vulner.value, ofArg)
                end if
                if result == null then continue
                object = result
                result = {
                    "publicAddr": Intrinsics.publicAddress,
                    "localAddr": Intrinsics.localAddress,
                    "metalib": exploit.metalib,
                    "address": exploit.address,
                    "vulner": vulner,
                    "ofArg": null,
                    "object": object,
                }
                if ofArg != null then result.ofArg = ofArg
                results.push(result)
            end for
        end for
    end for

    if results.len == 0 then return Console.error(Messages.ErrorNoVulnerabilitiesInLibraries)

    Console.log(Messages.LogAddingNewSessions)
    for result in results
        object = result.object
        type = typeof(object)

        if object isa string or object isa number then continue

        intrinsics = deepCopy(Intrinsics)
        intrinsics.shell = null
        intrinsics.computer = null
        intrinsics.file = null
        intrinsics.publicAddress = result.publicAddr
        intrinsics.localAddress = result.localAddr
        intrinsics.isConnectionRemote = true

        if type == "shell" then
            intrinsics.shell = object
            intrinsics.computer = intrinsics.shell.host_computer
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "computer" then
            intrinsics.computer = object
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "file" then
            fd = object
            while fd.parent
                fd = fd.parent
            end while
            intrinsics.file = fd
        end if

        SessionsHelpers.add(intrinsics)
    end for

    Console.log(Messages.LogCompilingExploitResults)
    outputs = {}
    for result in results
        library = result.metalib.lib_name
        version = result.metalib.version
        address = result.address
        vulner = result.vulner.value
        ofArg = ""
        object = result.object
        type = typeof(object)
        if result.ofArg then ofArg = result.ofArg

        key = [library,version,ofArg].join(" ")
        if outputs.indexes.indexOf(key) == null then
            outputs[key] = [address,vulner,type].join(" ")
        else
            outputs[key] = outputs[key]+char(10)+[address,vulner,type].join(" ")
        end if
    end for

    if outputs.len == 0 then return Console.error(Messages.ErrorNoUsefullExploits)

    Console.log(Messages.LogUsefullExploits)
    counter = 0
    for kv in outputs
        Console.log(Messages.LogVulnerabilitesIn, {"LIBRARY": kv.key})
        output = Messages.ExploitsHeader+char(10)+kv.value

        lines = output.split(char(10))
        typePredicate = function(iItem, jItem)
            priority = {
                "shell": 0,
                "computer": 1,
                "file": 2, 
                "string": 3,
                "number": 4,
            }
            iType = iItem.split(" ")[2]
            jType = jItem.split(" ")[2]
            return priority[iType] > priority[jType]
        end function
        mergeSort(lines, @typePredicate, 1)
        
        output = lines.join(char(10))
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))

        counter = counter + 1
        if counter != outputs.len then print(" ")
    end for

    Console.log(Messages.LogSuccessfullSessionsUpdate)
end function


command "nemesis", ["ns"], Const.host, Messages.HelpEntryNemesis, function(arguments)
    Conditions.argumentsMoreThan(arguments, 2)
    Conditions.host
    Conditions.network
    Conditions.metaxploit

    metaxploit = Libs.metaxploit

    addr = str(arguments.pull)
    argLocAddr = str(arguments.pull)
    argPort = arguments.pull
    ofArgs = [null]

    router = getNetworkNode(addr)
    if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
    addr = router.public_ip
    if isNodeLocallyAccessible(router) then addr = router.local_ip

    ofArgs = ofArgs + fmap(@str, arguments) + router.devices_lan_ip

    targets = []
    if isNodeLocallyAccessible(router) then
        for port in getPublicPortsWithLocalStates(addr) + getLocalPorts(addr)
            target = {
                "publicAddr": router.public_ip,
                "localAddr": port.get_lan_ip,
                "ip": port.get_lan_ip,
                "port": port.port_number,
            }
            targets.push(target)
        end for
        for localAddr in router.devices_lan_ip
            node = null
            isRouter = false
            if isNodeLocallyAccessible(router) then
                node = getNetworkNode(localAddr)
                if node then isRouter = true
            end if
            if isRouter then
                ofArgs = ofArgs + node.devices_lan_ip
                target = {
                    "publicAddr": node.public_ip,
                    "localAddr": localAddr,
                    "ip": localAddr,
                    "port": 0,
                }
                targets.push(target)
            end if
        end for
    else
        for port in router.used_ports
            target = {
                "publicAddr": router.public_ip,
                "localAddr": port.get_lan_ip,
                "ip": router.public_ip,
                "port": port.port_number,
            }
            targets.push(target)
        end for
        target = {
            "publicAddr": router.public_ip,
            "localAddr": router.local_ip,
            "ip": router.public_ip,
            "port": 0,
        }
        targets.push(target)
    end if
    targets = removeDuplicates(targets)
    ofArgs = removeDuplicates(ofArgs)

    libraries = []
    for target in targets
        if "all".indexOf(argLocAddr) != 0 and target.localAddr != argLocAddr then continue
        if "all".indexOf(argPort) != 0 and target.port != argPort then continue
        netSession = metaxploit.net_use(target.ip, target.port)
        if not netSession then continue
        metalib = netSession.dump_lib
        library = {
            "publicAddr": target.publicAddr,
            "localAddr": target.localAddr,
            "port": target.port,
            "metalib": metalib,
        }
        libraries.push(library)
    end for

    Console.log(Messages.LogScanningRemoteLibraries, {"AMOUNT": libraries.len})
    exploits = []
    for library in libraries
        memory = metaxploit.scan(library.metalib)
        for address in memory
            vulners = scanMemoryAddress(metaxploit, library.metalib, address)
            exploit = {
                "publicAddr": library.publicAddr,
                "localAddr": library.localAddr,
                "port": library.port,
                "metalib": library.metalib,
                "address": address,
                "vulners": vulners,
            }
            exploits.push(exploit)
        end for
    end for

    if exploits.len == 0 then return Console.error(Messages.ErrorNoExploitsInScannedLibraries)
    
    Console.log(Messages.LogExploitingVulnerabilities)
    results = []
    for exploit in exploits
        for vulner in exploit.vulners
            ofArgs = [null]
            if arguments.len > 0 then ofArgs = ofArgs + arguments
            ofArgs = removeDuplicates(ofArgs)
            for ofArg in ofArgs
                if ofArg == null then
                    result = exploit.metalib.overflow(exploit.address, vulner.value)
                else
                    result = exploit.metalib.overflow(exploit.address, vulner.value, str(ofArg))
                end if
                if result == null then continue
                object = result
                result = {
                    "publicAddr": exploit.publicAddr,
                    "localAddr": exploit.localAddr,
                    "port": exploit.port,
                    "metalib": exploit.metalib,
                    "address": exploit.address,
                    "vulner": vulner,
                    "ofArg": null,
                    "object": object,
                }
                if ofArg != null then result.ofArg = ofArg
                results.push(result)
            end for
        end for
    end for

    if results.len == 0 then return Console.error(Messages.ErrorNoVulnerabilitiesInLibraries)

    Console.log(Messages.LogAddingNewSessions)
    for result in results
        object = result.object
        type = typeof(object)

        if object isa string or object isa number then continue

        intrinsics = deepCopy(Intrinsics)
        intrinsics.shell = null
        intrinsics.computer = null
        intrinsics.file = null
        intrinsics.publicAddress = result.publicAddr
        intrinsics.localAddress = result.localAddr
        intrinsics.port = result.port
        intrinsics.isConnectionRemote = true

        if type == "shell" then
            intrinsics.shell = object
            intrinsics.computer = intrinsics.shell.host_computer
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "computer" then
            intrinsics.computer = object
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "file" then
            fd = object
            while fd.parent
                fd = fd.parent
            end while
            intrinsics.file = fd
        end if

        if result.ofArg != null and is_valid_ip(result.ofArg) then intrinsics.localAddress = result.ofArg

        SessionsHelpers.add(intrinsics)
    end for

    Console.log(Messages.LogCompilingExploitResults)
    outputs = {}
    for result in results
        library = result.metalib.lib_name
        version = result.metalib.version
        address = result.address
        vulner = result.vulner.value
        ofArg = ""
        object = result.object
        type = typeof(object)
        if result.ofArg then ofArg = result.ofArg

        key = [library,version,ofArg].join(" ")
        if outputs.indexes.indexOf(key) == null then
            outputs[key] = [address,vulner,type].join(" ")
        else
            outputs[key] = outputs[key]+char(10)+[address,vulner,type].join(" ")
        end if
    end for

    if outputs.len == 0 then return Console.error(Messages.ErrorNoUsefullExploits)

    Console.log(Messages.LogUsefullExploits)
    counter = 0
    for kv in outputs
        Console.log(Messages.LogVulnerabilitesIn, {"LIBRARY": kv.key})
        output = Messages.ExploitsHeader+char(10)+kv.value

        lines = output.split(char(10))
        typePredicate = function(iItem, jItem)
            priority = {
                "shell": 0,
                "computer": 1,
                "file": 2, 
                "string": 3,
                "number": 4,
            }
            iType = iItem.split(" ")[2]
            jType = jItem.split(" ")[2]
            return priority[iType] > priority[jType]
        end function
        mergeSort(lines, @typePredicate, 1)
        
        output = lines.join(char(10))
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))

        counter = counter + 1
        if counter != outputs.len then print(" ")
    end for

    Console.log(Messages.LogSuccessfullSessionsUpdate)
end function




command "hostify", [], Const.shell, Messages.HelpEntryHostify, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.remote
    Conditions.shell(["shell"])
    Conditions.network

    Console.log(Messages.LogLookingForPermissivePathToUploadInto)
    fdPermissive = findPermissivePath(Intrinsics.file, "wx")
    if not fdPermissive then return Console.error(Messages.ErrorCouldNotFindPermissivePathToUploadInto)

    marinettePath = null
    fdMarinette = findMyself(Intrinsics.shell, Config.identificator, "--identify-marinette --password "+Var.password, true)
    if fdMarinette and fdMarinette.has_permission("x") then marinettePath = fdMarinette.path
    if not marinettePath then
        Console.log(Messages.LogLookingForMyself)
        // Now that I think of it - this is potentially a security vulnerability. Should be cautious.
        fdMarinette = findMyself(get_shell, Config.identificator, "--identify-marinette --password "+Var.password)
        if not fdMarinette then return Console.error(Messages.ErrorCouldNotFindMyself)
        
        Console.log(Messages.LogUploadingNeccessary)
        fdBin = get_shell.host_computer.File(fdMarinette.path)
        result = get_shell.scp(fdMarinette.path, fdPermissive.path, Intrinsics.shell)
        if result isa string then
            return Console.error(Messages.ErrorStringGeneral, {"FUNC": "scp", "ERROR": result})
        else if not result then
            return Console.error(Messages.ErrorUnknown)
        end if
        Console.log("<i>"+fdMarinette.path+"</i> -> <i>"+fdPermissive.path)
        marinettePath = fdPermissive.path+"/"+fdMarinette.name
    end if

    Intrinsics.isConnectionRemote = false

    shared = get_custom_object
    shared.Var = deepCopy(Var)
    shared.Intrinsics = deepCopy(Intrinsics)
    shared.Libs = deepCopy(Libs)
    shared.Sessions = deepCopy(Sessions)

    Console.log(Messages.LogSessionHostifiedSuccessfully)

    Intrinsics.shell.launch(marinettePath, "--no-ascii-art --password "+Var.password)
    exit
end function


command "console", ["con"], Const.shell, Messages.HelpEntryConsole, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.shell(["shell"])

    Console.log(Messages.LogStartingInGameConsole)
    Intrinsics.shell.start_terminal
    exit
end function




command "walk", ["w", "cd"], Const.file, Messages.HelpEntryWalk, function(arguments)
    Conditions.arguments(arguments, 2)

    command = str(arguments[0])
    s = arguments[1]
    path = str(arguments[1])

    fd = Intrinsics.file

    if "back".indexOf(command) == 0 then
        if not s isa number then return Console.error(Messages.ErrorUnknownArguments)
        i = 0; while i < s; i = i + 1
            if fd.parent then fd = fd.parent
        end while
        Intrinsics.file = fd
    else if "into".indexOf(command) == 0 then
        fd = iterateToPath(fd, path)
        if not fd or not fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotDirectory)
        Intrinsics.file = fd
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if
end function


command "ocleaner", ["oc"], Const.file, Messages.HelpEntryOpenCleaner, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)

    command = fmap(@str, arguments).join(" ")

    object = Intrinsics.file
    if Intrinsics.computer then object = Intrinsics.computer

    if arguments.len == 1 and command == "interactive" then command = null
    openCleaner(object, Theme, Messages, command)
end function
